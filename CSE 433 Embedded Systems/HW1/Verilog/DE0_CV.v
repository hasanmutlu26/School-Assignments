
//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================

module DE0_CV(

	//////////// CLOCK //////////
	input 		          		CLOCK_50,


	//////////// KEY //////////
	input 		     [3:0]		KEY,
	input 		          		RESET_N,

	//////////// LED //////////
	output		     [9:0]		LEDR,


	//////////// SW //////////
	input 		     [9:0]		SW

);



//=======================================================
//  REG/WIRE declarations
//=======================================================
wire [7:0] v;
wire b, r, w;
wire min1, min2, min3, dang;
wire sec1, sec2, sec3;

wire n2_1, n2_2, n2_3, n2_4;
wire n1_1, n1_2, n1_3, n1_4, n1_5, n1_6;
wire n0_1, n0_2, n0_3, n0_4, n0_5;
wire [2:0] n;

wire  [2:0] mem;





//=======================================================
//  Structural coding
//=======================================================
buf(min3, ~KEY[0]);
buf(min2, ~KEY[1]);
buf(min1, ~KEY[2]);

buf(v[0], SW[0]);
buf(v[1], SW[1]);
buf(v[2], SW[2]);
buf(v[3], SW[3]);
buf(v[4], SW[4]);
buf(v[5], SW[5]);
buf(v[6], SW[6]);
buf(v[7], SW[7]);

buf(r, SW[8]);
buf(w, SW[9]);
buf(b, ~KEY[3]);

buf(LEDR[0], sec1);
buf(LEDR[1], sec2);
buf(LEDR[2], sec3);

buf(LEDR[9], mem[2]);
buf(LEDR[8], mem[1]);
buf(LEDR[7], mem[0]);
buf(LEDR[5], KEY[3]);




registers regs(mem, n, CLOCK_50);
danger danger(dang, v, b, r, w);

and(n2_1, ~mem[2], mem[1], mem[0], min3, dang);
and(n2_2, mem[2], ~mem[1], ~mem[0], dang);
and(n2_3, mem[2], ~mem[1], mem[0], dang);
and(n2_4, mem[2], mem[1], ~mem[0], ~min3, dang);
or(n[2], n2_1, n2_2, n2_3, n2_4);

and(n1_1, mem[2], ~mem[1], mem[0], min2);
and(n1_2, ~mem[2], mem[1], ~min3);
and(n1_3, ~mem[2], ~mem[1], mem[0], min1);
and(n1_4, ~mem[2], ~dang);
and(n1_5, mem[1], ~mem[0]);
and(n1_6, ~mem[1], ~dang);
or(n[1], n1_1, n1_2, n1_3, n1_4, n1_5, n1_6);


and(n0_1, ~mem[2], ~mem[1], dang);
and(n0_2, ~mem[2], ~min3, dang);
and(n0_3, mem[1], ~mem[0], min3, dang);
and(n0_4, ~mem[1], ~mem[0], min2, dang);
and(n0_5, ~mem[1], mem[0], ~min2, dang);
or(n[0], n0_1, n0_2, n0_3, n0_4, n0_5);

and(sec1, mem[2], ~mem[1], mem[0]);
and(sec2, mem[2], ~mem[1], ~mem[0]);
and(sec3, ~mem[2], mem[1], mem[0]);


 



endmodule
